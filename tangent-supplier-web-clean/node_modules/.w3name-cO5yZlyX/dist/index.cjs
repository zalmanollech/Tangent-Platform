"use strict";var e=require("@libp2p/crypto/keys"),t=require("multiformats/bases/base36"),r=require("multiformats/bases/base64"),n=require("multiformats/cid"),i=require("multiformats/hashes/digest"),a=require("ipns"),s=require("ipns/validator"),o=require("cborg"),c=require("./service.cjs");function u(e){var t=Object.create(null);return e&&Object.keys(e).forEach((function(r){if("default"!==r){var n=Object.getOwnPropertyDescriptor(e,r);Object.defineProperty(t,r,n.get?n:{enumerable:!0,get:function(){return e[r]}})}})),t.default=e,Object.freeze(t)}var l=u(i),d=u(a),y=u(o);const p=()=>new Date(Date.now()+31536e6).toISOString(),v=5n*60n*1000n*1000000n,w=new c;class b{_pubKey;_cid;constructor(e){this._pubKey=e,this._cid=e.toCID()}get bytes(){return this._cid.bytes}toString(){return this._cid.toString(t.base36)}}class m extends b{_privKey;constructor(e){super(e.publicKey),this._privKey=e}get key(){return this._privKey}}function f(r){const i=n.CID.parse(r,t.base36);if(114!==i.code)throw new Error(`Invalid key, expected 114 codec code but got ${i.code}`);const a=e.publicKeyFromProtobuf(l.decode(i.multihash.bytes).bytes);return new b(a)}class h{_name;_value;_sequence;_validity;_ttl;constructor(e,t,r,n,i){if(this._name=e,"string"!=typeof t)throw new Error("invalid value");if(this._value=t,"bigint"!=typeof r)throw new Error("invalid sequence number");if(this._sequence=r,"string"!=typeof n||Number.isNaN(new Date(n).getTime()))throw new Error("invalid validity");this._validity=n;const a=i?.ttl??v;if("bigint"!=typeof a)throw new Error("invalid TTL");this._ttl=a}get name(){return this._name}get value(){return this._value}get sequence(){return this._sequence}get validity(){return this._validity}get ttl(){return this._ttl}static encode(e){return y.encode({name:e._name.toString(),value:e._value,sequence:e._sequence,validity:e._validity,...null!=e._ttl?{ttl:e._ttl}:{}})}static decode(e){const t=y.decode(e),r=f(t.name);return new h(r,t.value,BigInt(t.sequence),t.validity,{ttl:null!=t.ttl?BigInt(t.ttl):void 0})}}async function g(e){const t=await e;if(t.ok)return t;let r;try{const e=await t.json();r=new Error(e.message)}catch(e){r=new Error(`unexpected response from API, cannot parse error response. Received status: ${t.status}`)}throw r}exports.Name=b,exports.Revision=h,exports.WritableName=m,exports.create=async function(){const t=await e.generateKeyPair("Ed25519",2048);return new m(t)},exports.from=async function(t){let r;try{r=e.privateKeyFromRaw(t)}catch{r=e.privateKeyFromProtobuf(t)}return new m(r)},exports.increment=async function(e,t){const r=e.sequence+1n;return new h(e.name,t,r,p())},exports.parse=f,exports.publish=async function(e,t,n=w){const i=new URL(`name/${e.name.toString()}`,n.endpoint),a=await d.createIPNSRecord(t,e.value,e.sequence,new Date(e.validity).getTime()-Date.now(),{ttlNs:e.ttl});await n.waitForRateLimit(),await g(fetch(i.toString(),{method:"POST",body:r.base64pad.baseEncode(d.marshalIPNSRecord(a))}))},exports.resolve=async function(t,i=w){const a=new URL(`name/${t.toString()}`,i.endpoint);await i.waitForRateLimit();const o=await g(fetch(a.toString())),{record:c}=await o.json(),u=r.base64pad.baseDecode(c),y=d.unmarshalIPNSRecord(u),p=n.CID.decode(t.bytes),v=e.publicKeyFromProtobuf(l.decode(p.multihash.bytes).bytes);return await s.validate(v,u),new h(t,y.value,y.sequence,y.validity,{ttl:y.ttl})},exports.v0=async function(e,t){return new h(e,t,0n,p())};
//# sourceMappingURL=index.cjs.map
