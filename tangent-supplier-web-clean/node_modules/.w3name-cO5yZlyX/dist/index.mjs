import{generateKeyPair as t,publicKeyFromProtobuf as e,privateKeyFromRaw as n,privateKeyFromProtobuf as i}from"@libp2p/crypto/keys";import{base36 as r}from"multiformats/bases/base36";import{base64pad as o}from"multiformats/bases/base64";import{CID as s}from"multiformats/cid";import*as a from"multiformats/hashes/digest";import*as c from"ipns";import{validate as u}from"ipns/validator";import*as l from"cborg";import d from"./service.mjs";const m=()=>new Date(Date.now()+31536e6).toISOString(),y=5n*60n*1000n*1000000n,w=new d;class h{_pubKey;_cid;constructor(t){this._pubKey=t,this._cid=t.toCID()}get bytes(){return this._cid.bytes}toString(){return this._cid.toString(r)}}class f extends h{_privKey;constructor(t){super(t.publicKey),this._privKey=t}get key(){return this._privKey}}async function p(){const e=await t("Ed25519",2048);return new f(e)}function v(t){const n=s.parse(t,r);if(114!==n.code)throw new Error(`Invalid key, expected 114 codec code but got ${n.code}`);const i=e(a.decode(n.multihash.bytes).bytes);return new h(i)}async function _(t){let e;try{e=n(t)}catch{e=i(t)}return new f(e)}async function g(t,e){return new S(t,e,0n,m())}async function b(t,e){const n=t.sequence+1n;return new S(t.name,e,n,m())}class S{_name;_value;_sequence;_validity;_ttl;constructor(t,e,n,i,r){if(this._name=t,"string"!=typeof e)throw new Error("invalid value");if(this._value=e,"bigint"!=typeof n)throw new Error("invalid sequence number");if(this._sequence=n,"string"!=typeof i||Number.isNaN(new Date(i).getTime()))throw new Error("invalid validity");this._validity=i;const o=r?.ttl??y;if("bigint"!=typeof o)throw new Error("invalid TTL");this._ttl=o}get name(){return this._name}get value(){return this._value}get sequence(){return this._sequence}get validity(){return this._validity}get ttl(){return this._ttl}static encode(t){return l.encode({name:t._name.toString(),value:t._value,sequence:t._sequence,validity:t._validity,...null!=t._ttl?{ttl:t._ttl}:{}})}static decode(t){const e=l.decode(t),n=v(e.name);return new S(n,e.value,BigInt(e.sequence),e.validity,{ttl:null!=e.ttl?BigInt(e.ttl):void 0})}}async function q(t,e,n=w){const i=new URL(`name/${t.name.toString()}`,n.endpoint),r=await c.createIPNSRecord(e,t.value,t.sequence,new Date(t.validity).getTime()-Date.now(),{ttlNs:t.ttl});await n.waitForRateLimit(),await I(fetch(i.toString(),{method:"POST",body:o.baseEncode(c.marshalIPNSRecord(r))}))}async function E(t,n=w){const i=new URL(`name/${t.toString()}`,n.endpoint);await n.waitForRateLimit();const r=await I(fetch(i.toString())),{record:l}=await r.json(),d=o.baseDecode(l),m=c.unmarshalIPNSRecord(d),y=s.decode(t.bytes),h=e(a.decode(y.multihash.bytes).bytes);return await u(h,d),new S(t,m.value,m.sequence,m.validity,{ttl:m.ttl})}async function I(t){const e=await t;if(e.ok)return e;let n;try{const t=await e.json();n=new Error(t.message)}catch(t){n=new Error(`unexpected response from API, cannot parse error response. Received status: ${e.status}`)}throw n}export{h as Name,S as Revision,f as WritableName,p as create,_ as from,b as increment,v as parse,q as publish,E as resolve,g as v0};
//# sourceMappingURL=index.mjs.map
