(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.Libp2PInterface = factory()}(typeof self !== 'undefined' ? self : this, function () {
"use strict";var Libp2PInterface=(()=>{var n=Object.defineProperty;var W=Object.getOwnPropertyDescriptor;var X=Object.getOwnPropertyNames;var Y=Object.prototype.hasOwnProperty;var Z=(t,r)=>{for(var e in r)n(t,e,{get:r[e],enumerable:!0})},$=(t,r,e,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let o of X(r))!Y.call(t,o)&&o!==e&&n(t,o,{get:()=>r[o],enumerable:!(s=W(r,o))||s.enumerable});return t};var k=t=>$(n({},"__esModule",{value:!0}),t);var fr={};Z(fr,{AbortError:()=>c,AlreadyStartedError:()=>M,ConnectionClosedError:()=>E,ConnectionClosingError:()=>f,ConnectionFailedError:()=>h,DialError:()=>N,FaultTolerance:()=>i,InvalidCIDError:()=>P,InvalidCryptoExchangeError:()=>l,InvalidMessageError:()=>C,InvalidMultiaddrError:()=>g,InvalidMultihashError:()=>A,InvalidParametersError:()=>u,InvalidPeerIdError:()=>I,InvalidPrivateKeyError:()=>x,InvalidPublicKeyError:()=>m,KEEP_ALIVE:()=>ar,LimitedConnectionError:()=>K,ListenError:()=>U,MuxerClosedError:()=>b,NotFoundError:()=>v,NotImplementedError:()=>F,NotStartedError:()=>D,ProtocolError:()=>w,StreamResetError:()=>S,StreamStateError:()=>y,StrictNoSign:()=>cr,StrictSign:()=>ir,TimeoutError:()=>T,TooManyInboundProtocolStreamsError:()=>R,TooManyOutboundProtocolStreamsError:()=>_,TopicValidatorResult:()=>a,TypedEventEmitter:()=>O,UnexpectedPeerError:()=>p,UnsupportedKeyTypeError:()=>B,UnsupportedOperationError:()=>d,UnsupportedProtocolError:()=>L,connectionSymbol:()=>q,contentRoutingSymbol:()=>tr,isConnection:()=>rr,isPeerId:()=>sr,isPrivateKey:()=>er,isPubSub:()=>pr,isPublicKey:()=>z,isStartable:()=>j,isTransport:()=>lr,peerDiscoverySymbol:()=>or,peerIdSymbol:()=>G,peerRoutingSymbol:()=>nr,pubSubSymbol:()=>H,serviceCapabilities:()=>xr,serviceDependencies:()=>dr,setMaxListeners:()=>Q,start:()=>ur,stop:()=>mr,transportSymbol:()=>J});var q=Symbol.for("@libp2p/connection");function rr(t){return t!=null&&!!t[q]}var tr=Symbol.for("@libp2p/content-routing");function z(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1"||t.type==="ECDSA")&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.toMultihash=="function"&&typeof t.toCID=="function"&&typeof t.verify=="function"}function er(t){return t==null?!1:(t.type==="RSA"||t.type==="Ed25519"||t.type==="secp256k1"||t.type==="ECDSA")&&z(t.publicKey)&&t.raw instanceof Uint8Array&&typeof t.equals=="function"&&typeof t.sign=="function"}var or=Symbol.for("@libp2p/peer-discovery");var G=Symbol.for("@libp2p/peer-id");function sr(t){return!!t?.[G]}var nr=Symbol.for("@libp2p/peer-routing");var ar="keep-alive";var ir="StrictSign",cr="StrictNoSign",a;(function(t){t.Accept="accept",t.Ignore="ignore",t.Reject="reject"})(a||(a={}));var H=Symbol.for("@libp2p/pubsub");function pr(t){return!!t?.[H]}var J=Symbol.for("@libp2p/transport");function lr(t){return t!=null&&!!t[J]}var i;(function(t){t[t.FATAL_ALL=0]="FATAL_ALL",t[t.NO_FATAL=1]="NO_FATAL"})(i||(i={}));var c=class extends Error{static name="AbortError";constructor(r="The operation was aborted"){super(r),this.name="AbortError"}},p=class extends Error{static name="UnexpectedPeerError";constructor(r="Unexpected Peer"){super(r),this.name="UnexpectedPeerError"}},l=class extends Error{static name="InvalidCryptoExchangeError";constructor(r="Invalid crypto exchange"){super(r),this.name="InvalidCryptoExchangeError"}},u=class extends Error{static name="InvalidParametersError";constructor(r="Invalid parameters"){super(r),this.name="InvalidParametersError"}},m=class extends Error{static name="InvalidPublicKeyError";constructor(r="Invalid public key"){super(r),this.name="InvalidPublicKeyError"}},x=class extends Error{static name="InvalidPrivateKeyError";constructor(r="Invalid private key"){super(r),this.name="InvalidPrivateKeyError"}},d=class extends Error{static name="UnsupportedOperationError";constructor(r="Unsupported operation"){super(r),this.name="UnsupportedOperationError"}},f=class extends Error{static name="ConnectionClosingError";constructor(r="The connection is closing"){super(r),this.name="ConnectionClosingError"}},E=class extends Error{static name="ConnectionClosedError";constructor(r="The connection is closed"){super(r),this.name="ConnectionClosedError"}},h=class extends Error{static name="ConnectionFailedError";constructor(r="Connection failed"){super(r),this.name="ConnectionFailedError"}},b=class extends Error{static name="MuxerClosedError";constructor(r="The muxer is closed"){super(r),this.name="MuxerClosedError"}},S=class extends Error{static name="StreamResetError";constructor(r="The stream has been reset"){super(r),this.name="StreamResetError"}},y=class extends Error{static name="StreamStateError";constructor(r="The stream is in an invalid state"){super(r),this.name="StreamStateError"}},v=class extends Error{static name="NotFoundError";constructor(r="Not found"){super(r),this.name="NotFoundError"}},I=class extends Error{static name="InvalidPeerIdError";constructor(r="Invalid PeerID"){super(r),this.name="InvalidPeerIdError"}},g=class extends Error{static name="InvalidMultiaddrError";constructor(r="Invalid multiaddr"){super(r),this.name="InvalidMultiaddrError"}},P=class extends Error{static name="InvalidCIDError";constructor(r="Invalid CID"){super(r),this.name="InvalidCIDError"}},A=class extends Error{static name="InvalidMultihashError";constructor(r="Invalid Multihash"){super(r),this.name="InvalidMultihashError"}},L=class extends Error{static name="UnsupportedProtocolError";constructor(r="Unsupported protocol error"){super(r),this.name="UnsupportedProtocolError"}},C=class extends Error{static name="InvalidMessageError";constructor(r="Invalid message"){super(r),this.name="InvalidMessageError"}},w=class extends Error{static name="ProtocolError";constructor(r="Protocol error"){super(r),this.name="ProtocolError"}},T=class extends Error{static name="TimeoutError";constructor(r="Timed out"){super(r),this.name="TimeoutError"}},D=class extends Error{static name="NotStartedError";constructor(r="Not started"){super(r),this.name="NotStartedError"}},M=class extends Error{static name="AlreadyStartedError";constructor(r="Already started"){super(r),this.name="AlreadyStartedError"}},N=class extends Error{static name="DialError";constructor(r="Dial error"){super(r),this.name="DialError"}},U=class extends Error{static name="ListenError";constructor(r="Listen error"){super(r),this.name="ListenError"}},K=class extends Error{static name="LimitedConnectionError";constructor(r="Limited connection"){super(r),this.name="LimitedConnectionError"}},R=class extends Error{static name="TooManyInboundProtocolStreamsError";constructor(r="Too many inbound protocol streams"){super(r),this.name="TooManyInboundProtocolStreamsError"}},_=class extends Error{static name="TooManyOutboundProtocolStreamsError";constructor(r="Too many outbound protocol streams"){super(r),this.name="TooManyOutboundProtocolStreamsError"}},B=class extends Error{static name="UnsupportedKeyTypeError";constructor(r="Unsupported key type"){super(r),this.name="UnsupportedKeyTypeError"}},F=class extends Error{static name="NotImplementedError";constructor(r="Not implemented"){super(r),this.name="NotImplementedError"}};function Q(){}var O=class extends EventTarget{#r=new Map;constructor(){super()}listenerCount(r){let e=this.#r.get(r);return e==null?0:e.length}addEventListener(r,e,s){super.addEventListener(r,e,s);let o=this.#r.get(r);o==null&&(o=[],this.#r.set(r,o)),o.push({callback:e,once:(s!==!0&&s!==!1&&s?.once)??!1})}removeEventListener(r,e,s){super.removeEventListener(r.toString(),e??null,s);let o=this.#r.get(r);o!=null&&(o=o.filter(({callback:V})=>V!==e),this.#r.set(r,o))}dispatchEvent(r){let e=super.dispatchEvent(r),s=this.#r.get(r.type);return s==null||(s=s.filter(({once:o})=>!o),this.#r.set(r.type,s)),e}safeDispatchEvent(r,e={}){return this.dispatchEvent(new CustomEvent(r,e))}};function j(t){return t!=null&&typeof t.start=="function"&&typeof t.stop=="function"}async function ur(...t){let r=[];for(let e of t)j(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStart!=null&&await e.beforeStart()})),await Promise.all(r.map(async e=>{await e.start()})),await Promise.all(r.map(async e=>{e.afterStart!=null&&await e.afterStart()}))}async function mr(...t){let r=[];for(let e of t)j(e)&&r.push(e);await Promise.all(r.map(async e=>{e.beforeStop!=null&&await e.beforeStop()})),await Promise.all(r.map(async e=>{await e.stop()})),await Promise.all(r.map(async e=>{e.afterStop!=null&&await e.afterStop()}))}var xr=Symbol.for("@libp2p/service-capabilities"),dr=Symbol.for("@libp2p/service-dependencies");return k(fr);})();
return Libp2PInterface}));
//# sourceMappingURL=index.min.js.map
